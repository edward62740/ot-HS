#include "app_algo.h"
#include "main.h"
#include "stdbool.h"

static const int32_t HUMIDITY_TRIG_TH_POS = 9000;
static const int32_t HUMIDITY_TRIG_TH_NEG = 7500;
static const uint8_t HUMIDITY_SAMPLES_TRIG_TH = 5;

typedef enum {
	STATE_INIT,
	STATE_MEAS,
	STATE_PRETRIG,
	STATE_HEATING,
	STATE_COOLDOWN,
	STATE_UNDEF = -1
} eStateFsm;

typedef enum {
	RES_NONE, RES_HEAT, RES_FAULT = -1
} eResFsm;

// Basic queue-like linked list for storing short-term sensor data
typedef struct node {
	struct node *next;
	SensorData_t data;
} SensorDataNode;

typedef struct {
	SensorDataNode *front;
	SensorDataNode *rear;
	uint8_t size;
} SensorQueueLL;

struct {
	SensorQueueLL *data_hist;
	eStateFsm cur_state;
} fsm;

SensorQueueLL* create_sensor_LL(void) {
	return calloc(1, sizeof(SensorQueueLL));
}

void update_sensor_LL(SensorQueueLL *ll, SensorData_t dat) {
	SensorDataNode *new = calloc(1, sizeof(SensorQueueLL));
	new->data = dat;
	if (ll->size == 0) {
		ll->front = new;
		ll->rear = new;
		ll->size++;
	} else {
		if (ll->size >= 10) {
			SensorDataNode *tmp = ll->front;
			ll->front = tmp->next;
			free(tmp);
			ll->size--;
		}
		SensorDataNode *tmp = ll->rear;
		tmp->next = new;
		ll->rear = new;
		ll->size++;
	}
}

uint8_t traverse_sensor_LL(SensorQueueLL *ll, bool isHum, int32_t l_th,
		int32_t u_th, int32_t *avg_temp, int32_t *avg_hum) {
	SensorDataNode *cur = ll->front;
	uint8_t ret = 0, ctr = 0;
	while (cur != ll->rear && cur) {
		if (isHum && (cur->data.humidity < l_th || cur->data->humidity > u_th))
			ret++;
		else if (!isHum
				&& (cur->data->temp_main < l_th || cur->data->temp_main > u_th))
			ret++;
		cur = cur->next;
		(*avg_temp) += cur->data->temp_main;
		(*avg_hum) += cur->data->humidity;
		ctr++;
	}
	(*avg_temp) /= ctr;
	(*avg_hum) /= ctr;
	return ret;
}

void app_algo_init() {
	fsm.data_hist = create_sensor_LL();
	fsm.cur_state = STATE_INIT;
}

eResFsm app_algo_proc(SensorData_t data, bool ext_sig_reset) {
	update_sensor_LL(fsm.data_hist, data);
	if (fsm.cur_state == STATE_INIT && !ext_sig_reset) {
		fsm.cur_state = STATE_MEAS;
	}
	switch (fsm.cur_state) {
	case STATE_MEAS: {

		int32_t t, h;
		uint8_t ct = traverse_sensor_LL(fsm.data_hist, true, INT_MIN,
				HUMIDITY_TRIG_TH_POS, t, h);
		break;
	}
	case STATE_PRETRIG: {
		if (data.humidity < HUMIDITY_TRIG_TH_POS)
			break;
		int32_t t, h;
		uint8_t ct = traverse_sensor_LL(fsm.data_hist, true, INT_MIN,
				HUMIDITY_TRIG_TH_POS, t, h);
		if (ct >= HUMIDITY_SAMPLES_TRIG_TH)
			fsm.cur_state = STATE_HEATING;
		break;
	}

	case STATE_HEATING:
		break;
	case STATE_COOLDOWN:
		break;
	case STATE_UNDEF:
		break;
	}
}

